#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
The Cornetto Convertor to MySQL converts the Cornetto XML datbase files to SQL file in order to import into a MySQL database.

NOTE:
	Please, first use the scheme file (read the Installation below!) to create the MySQL scheme, before applying the insert queries (generated by this script).


Requirements
============
In order to use this Cornetto to MySQL convertor, the following requirements should be met:
	- Python 2.7 is installed
	- MySQL database is installed & running
	- You got the full copy of the Cornetto database (from: http://tst-centrale.org/producten/lexica/cornetto/7-56)

Optionally:
	- Get the word count database (wcl) as well 
		(use the Python scripts from: https://github.com/emsrc/pycornetto/tree/master/bin)

Note:
	The documentation is based on GNU/Linux operating system, but it should also work with Windows or Mac OS X.

Installation
============
See the commands below, which should be executed into a terminal.

	1. Login into MySQL. 
	2. Create a MySQL database called 'cornetto' (if necessary: drop existing database).
	3. Import the scheme sql file (cornetto_mysql_scheme.sql) into the cornetto database.
	4. Increase Max Allowed Packet of the MySQL server
	5. Import the data sql file (cornetto_mysql_data.sql) into the cornetto database (get some coffee, this can take at least 10 min.).
	6. Done :) You can now use the MySQL version of the Cornetto database!

Enter the commands respectively:
	- mysql -u root -p --show-warnings
	- DROP DATABASE cornetto; CREATE DATABASE cornetto; USE cornetto; source cornetto_mysql_schema.sql; SET GLOBAL max_allowed_packet=1073741824;
	- source cornetto_mysql_data.sql;

Help
====
MySQL database can be used in all kinds of code and applications, e.g. PHP and Python often in combination with 'MySQL driver'.

You can use the diagram image (cornetto_mysql.png) for the database enhanced entityâ€“relationship (EER) diagram.
This diagram helps you understand how the database is set up and how to write your MySQL queries.

Credits & License
=================
The Cornetto Convertor to MySQL is created & developed by Melroy van den Berg.
The code below is under Apache License, Version 2.0. Please check the LICENSE-2.0.txt file for more info.

Copyright 2014 Melroy van den Berg
"""

__author__ = 'Melroy van den Berg <melroy@melroy.org>'
__version__ = '1.0'

import sys
import xml.etree.ElementTree as ET
import xml.etree.cElementTree as etree
from datetime import datetime

DEBUG = False
PRINT_OUTPUT_LU = False
PRINT_OUTPUT_SYN = False
PRINT_TABLE_COLUMNS_LU = False
PRINT_TABLE_COLUMNS_SYN = False

# Output file
OUTPUT_FILE = 'cornetto_mysql_data.sql'

# Database name
DATABASE_NAME = 'cornetto'

# Database lexical units table names
TABLE_SUBCOUNTS = DATABASE_NAME + '_lexical_units'
TABLE_EXAMPLES = DATABASE_NAME + '_examples'
TABLE_COMBIPAIRS = DATABASE_NAME + '_combipairs'
TABLE_STYNTAX_COMPLEMENTATIONS = DATABASE_NAME + '_syntax_complementations'
TABLE_SEMATICS_CASEFRAME_ARGS = DATABASE_NAME + '_semantics_caseframe_args'
TABLE_MORPHOLOGY_FLEX_CONJUGATION = DATABASE_NAME + '_morphology_flex_conjugation'
TABLE_MORPHOLOGY_PLURFORMS = DATABASE_NAME + '_morphology_plurforms'
TABLE_SEMANTICS_SYNONYMS = DATABASE_NAME + '_semantics_synonyms'
TABLE_SELRESTRICTIONS = DATABASE_NAME + '_semantics_selrestrictions'

# Database synset table names
TABLE_SYNSETS = DATABASE_NAME + '_synsets'
TABLE_SYNONYMS = DATABASE_NAME + '_synonyms'
TABLE_WORDNET_DOMAINS = DATABASE_NAME + '_wordnet_domains'
TABLE_WORDNET_INTERNAL_RELATIONS = DATABASE_NAME + '_wordnet_internal_relations'
TABLE_WORDNET_EQUIVALENCE_RELATIONS = DATABASE_NAME + '_wordnet_equivalence_relations'
TABLE_SUMO_RELATIONS = DATABASE_NAME + '_sumo_ontology_relations'

# Renamed primary keys
SUBCOUNTS_ID_OLD = 'cdb_lu_c_lu_id'
SUBCOUNTS_ID = 'lu_id'

EXAMPLES_ID_OLD = 'example_r_ex_id'
EXAMPLES_ID = 'ex_id'

SYNSETS_ID = 'synset_id'
SYNSETS_ID_OLD = 'cdb_synset_c_sy_id'

class ConvertToSQL:	
	def __init__(self):
		# init all keys for lexical unit tables
		self.subcounts_keys = []
		self.examples_keys = []
		self.combipair_keys = []
		self.complementations_keys = []
		self.semantics_caseframe_args = []
		self.morphology_flex_conjugation_keys = []
		self.morphology_plurforms_keys = []
		self.semantics_synonyms_keys = []
		self.selrestrictions_keys = []

		# init all keys for synset tables
		self.synset_keys = []
		self.synonyms_keys = []
		self.wordnet_domains_keys = []
		self.wordnet_internal_relations_keys = []
		self.wordnet_equivalence_relations_keys = []
		self.sumo_relations_keys = []

		print "Start importing XML files..."
		self.startTime = datetime.now()
		self.root_subcounts = {}
		self.root_synset = {}
		try:
			file_input_lu = 'cdb_lu.xml'
			file_input_synset = 'cdb_syn.xml'

			tree_lu = ET.parse(file_input_lu)
			self.root_lu = tree_lu.getroot()
			tree_synset = ET.parse(file_input_synset)
			self.root_synset = tree_synset.getroot()
		except IOError:
			print "\n\n! XML file(s) are NOT found !"
			print "=============================="
			print "Please use: cdb_lu.xml file name for the Cornetto lexical unit (subcounts) xml file."
			print "And use: cdb_syn.xml for the Cornetto Synset xml file."
			print "Rename your files and try again...\n\n"
		except ET.ParseError:
			print "\n\n! XML file(s) could NOT be parsed !"
			print "===================================="
			print "Did you use the correct XML files? Are they corrupt?\n\n"
		else:
			print "Done importing!"

	def convert(self):
		print "Start parsing..."
		# init all lexical unit tables
		self.overall_sql_subcounts_output = []		
		self.overall_sql_examples_output = []
		self.overall_sql_combipair_output = []
		self.overall_sql_complementations_output = []
		self.overall_sql_semantics_caseframe_args_output = []
		self.overall_sql_morphology_flex_conjugation_output = []
		self.overall_sql_morphology_plurforms_output = []
		self.overall_sql_semantics_synonyms_output = []
		self.overall_sql_selrestrictions_output = []

		# init all synset tables		
		self.overall_sql_synset_output = []
		self.overall_sql_synonyms_output = []
		self.overall_sql_wordnet_domains_output = []
		self.overall_sql_wordnet_internal_relations_output = []
		self.overall_sql_wordnet_equivalence_relations_output = []
		self.overall_sql_sumo_relations_output = []

		# Generate SQL queries from XML structures
		self.parseSynsetFile(self.root_synset)
		self.parseLexicalUnitFile(self.root_lu)

		dataPresent = self.isAllDataPresent()
		if dataPresent:
			# write queries to file
			self.writeToFile(self.overall_sql_subcounts_output,
							self.overall_sql_examples_output,
							self.overall_sql_combipair_output,
							self.overall_sql_complementations_output,
							self.overall_sql_semantics_caseframe_args_output,
							self.overall_sql_morphology_flex_conjugation_output,
							self.overall_sql_morphology_plurforms_output,
							self.overall_sql_semantics_synonyms_output,
							self.overall_sql_selrestrictions_output,
			
							self.overall_sql_synset_output,
							self.overall_sql_synonyms_output,
							self.overall_sql_wordnet_domains_output,
							self.overall_sql_wordnet_internal_relations_output,
							self.overall_sql_wordnet_equivalence_relations_output,
							self.overall_sql_sumo_relations_output
							)
			print "Finished writing to file!"
		else:
			print "Not written to file!"

		self.debugOutput()

		executionTime = datetime.now()-self.startTime
		print "\n\nTotal time duration: ", executionTime

	def parseSynsetFile(self, root):
		synset_id = '-1'
		# loop to each synonym in the synset database (syn)
		for synset in root:
			# init synset table
			sql_synset_output = []
			sql_synset_output.append('INSERT INTO `' + TABLE_SYNSETS + '` ({0}) VALUES (')		
			sql_synset_keys = []	
			sql_synset_values = []

			# Get the synset_id (d_synset_id)
			prefix_name = synset.tag + "_" 
			for name, value in synset.attrib.items():
				if name:
					key = self.covertKey(prefix_name + name, TABLE_SYNSETS)
					value = self.convertValue(value)
					if key == '`' + SYNSETS_ID_OLD + '`':
						# store the current synset_id
						synset_id = value
						# simplify the primary key
						sql_synset_keys.append('`' + SYNSETS_ID + '`')
					else:
						sql_synset_keys.append(key)
					sql_synset_values.append(value)
			
			# get all sub elements
			for element in synset:
				# synonyms
				if element.tag == 'synonyms':
					self.saveMultipleAttribStruct(element, SYNSETS_ID, synset_id, self.overall_sql_synonyms_output, TABLE_SYNONYMS)

				# wn_domains
				if element.tag == 'wn_domains':
					self.saveMultipleAttribStruct(element, SYNSETS_ID, synset_id, self.overall_sql_wordnet_domains_output, TABLE_WORDNET_DOMAINS)

				# wn_internal_relations
				if element.tag == 'wn_internal_relations':
					self.saveMultipleSubAttribStruct(element, SYNSETS_ID, synset_id, 
												self.overall_sql_wordnet_internal_relations_output, TABLE_WORDNET_INTERNAL_RELATIONS)

				# wn_equivalence_relations
				if element.tag == 'wn_equivalence_relations':
					self.saveMultipleSubAttribStruct(element, SYNSETS_ID, synset_id,
												self.overall_sql_wordnet_equivalence_relations_output, TABLE_WORDNET_EQUIVALENCE_RELATIONS)

				# sumo_relations
				if element.tag == 'sumo_relations':
					self.saveMultipleAttribStruct(element, SYNSETS_ID, synset_id, self.overall_sql_sumo_relations_output, TABLE_SUMO_RELATIONS)


			# Combine synset query
			self.combineSQLQuery(sql_synset_output, sql_synset_keys, sql_synset_values, self.overall_sql_synset_output)
	
	def parseLexicalUnitFile(self, root):
		word_id = '-1'
		# loop to each word in the lexical unit database (subcounts)
		for cdb_lu in root:
			# init subcounts table
			sql_subcounts_output = []
			sql_subcounts_output.append('INSERT INTO `' + TABLE_SUBCOUNTS + '` ({0}) VALUES (')		
			sql_subcounts_keys = []	
			sql_subcounts_values = []
	
			# Get the word_id (cdb_lu)
			prefix_name = cdb_lu.tag + "_" 
			for name, value in cdb_lu.attrib.items():
				if value:
					key = self.covertKey(prefix_name + name, TABLE_SUBCOUNTS)
					value = self.convertValue(value)
					if key == '`' + SUBCOUNTS_ID_OLD + '`':
						# store the current word_id
						word_id = value
						# simplify the primary key
						sql_subcounts_keys.append('`' + SUBCOUNTS_ID + '`')
					else:
						sql_subcounts_keys.append(key)

					sql_subcounts_values.append(value)
					self.print_output(key, value)

			# get all sub elements
			for element in cdb_lu:
				if DEBUG: 
					print " --------"

				# form
				if element.tag == 'form':
					self.saveSimpleAttribStruct(element, sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		
				# syntax_noun
				if element.tag == 'syntax_noun':
					self.saveSimpleStruct(element, sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)

				# pragmatics
				if element.tag == 'pragmatics':
					self.saveSubAttribStruct(element, sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		
				# examples
				if element.tag == 'examples':
					# for every example		
					example_id = '-1'
					# @ATTENTION multi-row!
					for idx, example in enumerate(element):
						if DEBUG:
							print "(" + str(idx) + ")"
						# init examples table				
						sql_examples_output = []
						sql_examples_output.append('INSERT INTO `' + TABLE_EXAMPLES + '` ({0}) VALUES (')
						sql_examples_keys = []	
						sql_examples_values = []

						# Get the example_id
						prefix_name = example.tag + "_"
						for name, value in example.attrib.items():
							key = self.covertKey(prefix_name + name, TABLE_EXAMPLES)
							value = self.convertValue(value)
							if key == '`' + EXAMPLES_ID_OLD + '`':
								# store the current example_id
								example_id = value
								# simplify the primary key								
								sql_examples_keys.append('`' + EXAMPLES_ID + '`')
								sql_examples_values.append(value)
							self.print_output(key, value)

						# add foreign word_id (lu_id) to example table
						sql_examples_keys.append('`'+ SUBCOUNTS_ID +'`')
						sql_examples_values.append(word_id)

						for element in example:
							if element.tag == 'semantics_example':
								self.saveSimpleStruct(element, sql_examples_keys, sql_examples_values, TABLE_EXAMPLES)
							if element.tag == 'syntax_example':
								self.saveSubSubTableStruct(element, EXAMPLES_ID, example_id,
															'sy-combi', TABLE_COMBIPAIRS, self.overall_sql_combipair_output,
															sql_examples_keys, sql_examples_values, TABLE_EXAMPLES)
							if element.tag == 'form_example':
								self.saveSimpleStruct(element, sql_examples_keys, sql_examples_values, TABLE_EXAMPLES)

						self.combineSQLQuery(sql_examples_output, sql_examples_keys, sql_examples_values, self.overall_sql_examples_output)

				# semantics_noun
				if element.tag == 'semantics_noun':
					self.saveDeeperStruct(element, 'sem-definition', sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)

				# morphology_noun
				if element.tag == 'morphology_noun':
					self.saveSubTableStruct(element, SUBCOUNTS_ID, word_id,
											'morpho-plurforms', TABLE_MORPHOLOGY_PLURFORMS, self.overall_sql_morphology_plurforms_output,
											sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
				# morphology_verb
				if element.tag == 'morphology_verb':
					self.saveSubTableStruct(element, SUBCOUNTS_ID, word_id,
											'flex-conjugation', TABLE_MORPHOLOGY_FLEX_CONJUGATION, self.overall_sql_morphology_flex_conjugation_output,
											sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
				# syntax_verb
				if element.tag == 'syntax_verb':
					self.saveSubTableStruct(element, SUBCOUNTS_ID, word_id,
											'sy-complementation', TABLE_STYNTAX_COMPLEMENTATIONS, self.overall_sql_complementations_output,
											sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)

				# semantics_verb
				# @TODO get all data correctly, including sem-selrestrictions as well as sem-caseframe.args
				if element.tag == 'semantics_verb':
					self.saveDeeperSubSubTableStruct(element, SUBCOUNTS_ID, word_id,
												'sem-caseframe', 'args', TABLE_SEMATICS_CASEFRAME_ARGS, self.overall_sql_semantics_caseframe_args_output,
												sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)

				# sem-definition
				if element.tag == 'sem-definition':
					self.saveDeeperStruct(element, 'sem-def-noun', sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		
				# morphology_adj
				if element.tag == 'morphology_adj':
					self.saveDeeperStruct(element, 'mor-comparis', sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)

				# sem-synonyms
				if element.tag == 'sem-synonyms':
					self.saveMultipleAttribStruct(element, SUBCOUNTS_ID, word_id, self.overall_sql_semantics_synonyms_output, TABLE_SEMANTICS_SYNONYMS)

				# sem-hypernyms
				if element.tag == 'sem-hypernyms':
					self.saveSubAttribStruct(element, sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)

				# semantics_adj
				if element.tag == 'semantics_adj':
					self.saveSubSubTableStruct(element, SUBCOUNTS_ID, word_id,
											'sem-selrestrictions', TABLE_SELRESTRICTIONS, self.overall_sql_selrestrictions_output,
											sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
				# syntax_adj
				if element.tag == 'syntax_adj':
					self.saveSimpleStruct(element, sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)

			# Combine subcounts query
			self.combineSQLQuery(sql_subcounts_output, sql_subcounts_keys, sql_subcounts_values, self.overall_sql_subcounts_output)

	def isAllDataPresent(self):
		"""
		Check if all output data is present/parsed
		"""
		returnValue = False
		if len(self.overall_sql_subcounts_output) < 1:
			print "Subcounts XML file is not parsed! Failed!"
		elif len(self.overall_sql_examples_output) < 1:
			print "Examples in subcounts XML file is not parsed! Failed!"			
		elif len(self.overall_sql_combipair_output) < 1:
			print "Combipair table (in examples) in subcounts XML file is not parsed! Failed!"
		elif len(self.overall_sql_complementations_output) < 1:
			print "Complementations table (in syntax_verb) in subcounts XML file is not parsed! Failed!"
		elif len(self.overall_sql_semantics_caseframe_args_output) < 1:
			print "Semantics table (in semantics_verb) in subcounts XML file is not parsed! Failed!"
		elif len(self.overall_sql_morphology_flex_conjugation_output) < 1:
			print "Morphology flex conjugation table (in morphology_verb) in subcounts XML file is not parsed! Failed!"
		elif len(self.overall_sql_morphology_plurforms_output) < 1:
			print "Morphology plurforms table (in morphology_noun) in subcounts XML file is not parsed! Failed!"
		elif len(self.overall_sql_semantics_synonyms_output) < 1:
			print "Synonym table (in sem-synonyms) in subcounts XML file is not parsed! Failed!"
		elif len(self.overall_sql_synset_output) < 1:
			print "Synset table XML file is not parsed! Failed!"
		elif len(self.overall_sql_synonyms_output) < 1:
			print "Synset table XML file is not parsed! Failed!"
		elif len(self.overall_sql_wordnet_domains_output) < 1:
			print "Synset table XML file is not parsed! Failed!"
		elif len(self.overall_sql_wordnet_internal_relations_output) < 1:
			print "Synset table XML file is not parsed! Failed!"
		elif len(self.overall_sql_wordnet_equivalence_relations_output) < 1:
			print "Synset table XML file is not parsed! Failed!"
		elif len(self.overall_sql_sumo_relations_output) < 1:
			print "Synset table XML file is not parsed! Failed!"
		else:
			print "Done creating queries. Now writing to file..."
			returnValue = True
		return returnValue

	def debugOutput(self):
		"""
		Debugging output method
		"""
		# Create debug: lexical unit tables
		sql_subcounts_output = '\n'.join(self.overall_sql_subcounts_output)
		sql_examples_output = '\n'.join(self.overall_sql_examples_output)
		sql_combipair_output = '\n'.join(self.overall_sql_combipair_output)
		sql_complementations_output = '\n'.join(self.overall_sql_complementations_output)
		sql_semantics_caseframe_args_output = '\n'.join(self.overall_sql_semantics_caseframe_args_output)
		sql_morphology_flex_conjugation_output = '\n'.join(self.overall_sql_morphology_flex_conjugation_output)
		sql_morphology_plurforms_output = '\n'.join(self.overall_sql_morphology_plurforms_output)
		sql_semantics_synonyms_output = '\n'.join(self.overall_sql_semantics_synonyms_output)
		sql_selrestrictions_output = '\n'.join(self.overall_sql_selrestrictions_output)

		# Create debug: synset tables
		sql_synset_output = '\n'.join(self.overall_sql_synset_output)
		sql_synonyms_output = '\n'.join(self.overall_sql_synonyms_output)
		sql_wordnet_domains_output = '\n'.join(self.overall_sql_wordnet_domains_output)
		sql_wordnet_internal_relations_output = '\n'.join(self.overall_sql_wordnet_internal_relations_output)
		sql_wordnet_equivalence_relations_output = '\n'.join(self.overall_sql_wordnet_equivalence_relations_output)
		sql_sumo_relations_output = '\n'.join(self.overall_sql_sumo_relations_output)

		if PRINT_OUTPUT_LU:
			print "===================================="
			print "    " + TABLE_SUBCOUNTS + " table - SQL OUTPUT    "
			print "===================================="
			print sql_subcounts_output
			print "\n\n"
			print "===================================="
			print "    " + TABLE_EXAMPLES + " table - SQL OUTPUT     "
			print "===================================="			
			print sql_examples_output			
			print "\n\n"
			print "===================================="
			print "    " + TABLE_COMBIPAIRS + " table - SQL OUTPUT    "
			print "===================================="			
			print sql_combipair_output
			print "\n\n"
			print "====================================="
			print " " + TABLE_STYNTAX_COMPLEMENTATIONS + " table - SQL OUTPUT "
			print "====================================="			
			print sql_complementations_output
			print "\n\n"
			print "============================================="
			print " " + TABLE_SEMATICS_CASEFRAME_ARGS + " table - SQL OUTPUT "
			print "============================================="			
			print sql_semantics_caseframe_args_output
			print "\n\n"
			print "================================================"
			print " " + TABLE_MORPHOLOGY_FLEX_CONJUGATION + " table - SQL OUTPUT "
			print "================================================"			
			print sql_morphology_flex_conjugation_output
			print "\n\n"
			print "========================================="
			print " " + TABLE_MORPHOLOGY_PLURFORMS + "table - SQL OUTPUT "
			print "========================================="			
			print sql_morphology_plurforms_output
			print "\n\n"
			print "========================================="
			print " " + TABLE_SEMANTICS_SYNONYMS + " - SQL OUTPUT "
			print "========================================="			
			print sql_semantics_synonyms_output
			print "\n\n"
			print "========================================="
			print " " + TABLE_SELRESTRICTIONS + " - SQL OUTPUT "
			print "========================================="			
			print sql_selrestrictions_output

		if PRINT_OUTPUT_SYN:
			print "===================================="
			print "    " + TABLE_SYNSETS + " table - SQL OUTPUT    "
			print "===================================="
			print sql_synset_output
			print "\n\n"
			print "===================================="
			print "    " + TABLE_SYNONYMS + " table - SQL OUTPUT    "
			print "===================================="
			print sql_synonyms_output
			print "\n\n"
			print "===================================="
			print "    " + TABLE_WORDNET_DOMAINS + " table - SQL OUTPUT    "
			print "===================================="
			print sql_wordnet_domains_output
			print "\n\n"
			print "===================================="
			print "    " + TABLE_WORDNET_INTERNAL_RELATIONS + " table - SQL OUTPUT    "
			print "===================================="
			print sql_wordnet_internal_relations_output
			print "\n\n"
			print "===================================="
			print "    " + TABLE_WORDNET_EQUIVALENCE_RELATIONS + " table - SQL OUTPUT    "
			print "===================================="
			print sql_wordnet_equivalence_relations_output
			print "\n\n"
			print "===================================="
			print "    " + TABLE_SUMO_RELATIONS + " table - SQL OUTPUT    "
			print "===================================="
			print sql_sumo_relations_output

		if PRINT_TABLE_COLUMNS_LU:
			#####################
			## Post-processing ##
			#####################

			# Replace Subcounts ID
			self.subcounts_keys.remove(SUBCOUNTS_ID_OLD)
			self.subcounts_keys.append(SUBCOUNTS_ID)
			# Replace Examples ID
			self.examples_keys.remove(EXAMPLES_ID_OLD)
			self.examples_keys.append(EXAMPLES_ID)
			# Add foreign keys
			self.examples_keys.append(SUBCOUNTS_ID)
			self.combipair_keys.append(EXAMPLES_ID)
			self.complementations_keys.append(SUBCOUNTS_ID)
			self.semantics_caseframe_args.append(SUBCOUNTS_ID)
			self.morphology_flex_conjugation_keys.append(SUBCOUNTS_ID)
			self.morphology_plurforms_keys.append(SUBCOUNTS_ID)
			self.semantics_synonyms_keys.append(SUBCOUNTS_ID)
			self.selrestrictions_keys.append(SUBCOUNTS_ID)

			print "===================================="
			print "    " + TABLE_SUBCOUNTS + " table - COLUMNS OUTPUT    "
			print "===================================="
			self.printTableKeys(self.subcounts_keys)
			print "\n\n"
			print "===================================="
			print "    " + TABLE_EXAMPLES + " table - COLUMNS OUTPUT     "
			print "===================================="	
			self.printTableKeys(self.examples_keys)
			print "\n\n"
			print "===================================="
			print "    " + TABLE_COMBIPAIRS + " table - COLUMNS OUTPUT    "
			print "===================================="	
			self.printTableKeys(self.combipair_keys)
			print "\n\n"
			print "====================================="
			print " " + TABLE_STYNTAX_COMPLEMENTATIONS + " table - COLUMNS OUTPUT "
			print "====================================="
			self.printTableKeys(self.complementations_keys)
			print "\n\n"
			print "============================================="
			print " " + TABLE_SEMATICS_CASEFRAME_ARGS + " table - COLUMNS OUTPUT "
			print "============================================="
			self.printTableKeys(self.semantics_caseframe_args)
			print "\n\n"
			print "================================================"
			print " " + TABLE_MORPHOLOGY_FLEX_CONJUGATION + " table - COLUMNS OUTPUT "
			print "================================================"
			self.printTableKeys(self.morphology_flex_conjugation_keys)
			print "\n\n"
			print "========================================="
			print " " + TABLE_MORPHOLOGY_PLURFORMS + "table - COLUMNS OUTPUT "
			print "========================================="
			self.printTableKeys(self.morphology_plurforms_keys)
			print "\n\n"
			print "========================================="
			print " " + TABLE_SEMANTICS_SYNONYMS + " - COLUMNS OUTPUT "
			print "========================================="
			self.printTableKeys(self.semantics_synonyms_keys)
			print "\n\n"
			print "========================================="
			print " " + TABLE_SELRESTRICTIONS + " - COLUMNS OUTPUT "
			print "========================================="
			self.printTableKeys(self.selrestrictions_keys)

		if PRINT_TABLE_COLUMNS_SYN:
			#####################
			## Post-processing ##
			#####################

			# Replace Subcounts ID
			self.synset_keys.remove(SYNSETS_ID_OLD)
			self.synset_keys.append(SYNSETS_ID)
			# Add foreign keys
			self.synonyms_keys.append(SYNSETS_ID)
			self.wordnet_domains_keys.append(SYNSETS_ID)
			self.wordnet_internal_relations_keys.append(SYNSETS_ID)
			self.wordnet_equivalence_relations_keys.append(SYNSETS_ID)
			self.sumo_relations_keys.append(SYNSETS_ID)

			print "===================================="
			print "    " + TABLE_SYNSETS + " table - COLUMNS OUTPUT    "
			print "===================================="
			self.printTableKeys(self.synset_keys)
			print "\n\n"
			print "===================================="
			print "    " + TABLE_SYNONYMS + " table - COLUMNS OUTPUT     "
			print "===================================="	
			self.printTableKeys(self.synonyms_keys)
			print "\n\n"
			print "===================================="
			print "    " + TABLE_WORDNET_DOMAINS + " table - COLUMNS OUTPUT     "
			print "===================================="	
			self.printTableKeys(self.wordnet_domains_keys)
			print "\n\n"
			print "========================================="
			print " " + TABLE_WORDNET_INTERNAL_RELATIONS + " - COLUMNS OUTPUT "
			print "========================================="
			self.printTableKeys(self.wordnet_internal_relations_keys)
			print "\n\n"
			print "========================================="
			print " " + TABLE_WORDNET_EQUIVALENCE_RELATIONS + " - COLUMNS OUTPUT "
			print "========================================="
			self.printTableKeys(self.wordnet_equivalence_relations_keys)
			print "\n\n"
			print "========================================="
			print " " + TABLE_SUMO_RELATIONS + " - COLUMNS OUTPUT "
			print "========================================="
			self.printTableKeys(self.sumo_relations_keys)

	def convertValue(self, value):
		"""
		Help function for parsing every value in the query
		"""
		returnValue = ''	
		try:
			# digit (if any dot is present, remove it)
			if value.replace(".", "", 1).isdigit():
				returnValue = value
			# boolean
			elif value.lower() == 'true':
				returnValue = '1'
			elif value.lower() == 'false':
				returnValue = '0'
			elif value.lower() == 'yes':
				returnValue = '1'
			elif value.lower() == 'no':
				returnValue = '0'
			# string
			else:
				# Fix the single quote
				# Fix the } or { signs
				# Strip new lines from value
				# Convert to utf-8
				value = value.replace('\'', '\\\'')
				value = value.replace('{', '{{')
				value = value.replace('}', '}}')
				value = value.strip('\n')
				returnValue = "'" + value.encode('utf-8') + "'"
		except AttributeError as e:
			print "Error detecting when converting value!\n"
			print e
			print "\n\n"

		return returnValue

	def covertKey(self, key, table_name):
		"""
		Help function for every column in the query
		"""
		self.addKeyToKeyList(key, table_name)
		return "`" + key + "`"


	def addKeyToKeyList(self, key, table):
		"""
		Append the key (column name) to the correct table once
		"""
		appendToList = []

		if table == TABLE_SUBCOUNTS:
			appendToList = self.subcounts_keys
		elif table == TABLE_EXAMPLES:
			appendToList = self.examples_keys
		elif table == TABLE_COMBIPAIRS:
			appendToList = self.combipair_keys
		elif table == TABLE_STYNTAX_COMPLEMENTATIONS:
			appendToList = self.complementations_keys
		elif table == TABLE_SEMATICS_CASEFRAME_ARGS:
			appendToList = self.semantics_caseframe_args
		elif table == TABLE_MORPHOLOGY_FLEX_CONJUGATION:
			appendToList = self.morphology_flex_conjugation_keys 
		elif table == TABLE_MORPHOLOGY_PLURFORMS:
			appendToList = self.morphology_plurforms_keys 
		elif table == TABLE_SEMANTICS_SYNONYMS:
			appendToList = self.semantics_synonyms_keys
		elif table == TABLE_SELRESTRICTIONS:
			appendToList = self.selrestrictions_keys
		elif table == TABLE_SYNSETS:			
			appendToList = self.synset_keys
		elif table == TABLE_SYNONYMS:
			appendToList = self.synonyms_keys
		elif table == TABLE_WORDNET_DOMAINS:
			appendToList = self.wordnet_domains_keys
		elif table == TABLE_WORDNET_INTERNAL_RELATIONS:
			appendToList = self.wordnet_internal_relations_keys
		elif table == TABLE_WORDNET_EQUIVALENCE_RELATIONS:
			appendToList = self.wordnet_equivalence_relations_keys
		elif table == TABLE_SUMO_RELATIONS:
			appendToList = self.sumo_relations_keys

		# Check if key is not yet in the table list
		if key not in appendToList:
			appendToList.append(key)

	def printTableKeys(self, key_list):
		"""
		Help function for printing the keys to terminal
		"""
		# first sort the keys
		key_list.sort()		
		for key in key_list:
			print "Column: " + key

	def combineSQLQuery(self, sql_output, sql_keys, sql_values, overall_sql_output):
		"""
		Combine the SQL query together and add it to the overall output list
		"""
		# combine values, comma-seperated
		sql_values = ", ".join(sql_values)
		# append to query
		sql_output.append(sql_values)
		# add final query tag
		sql_output.append(');')

		# combine all querry parts to single string
		sql_output = ''.join(sql_output)
		# combine all keys
		sql_keys = ", ".join(sql_keys)
		# add them to the sql query
		sql_output = sql_output.format(str(sql_keys))

		# append the query to the overall result
		overall_sql_output.append(sql_output)

	#####################################
	##     XML Attrib help fuctions    ##
	#####################################
	def saveSimpleAttribStruct(self, element, sql_keys, sql_values, table_name):
		'''
		When there is one element with multiple attributes.
		Eg. 
			<form count="0" form-cat="adj" form-length="" form-spelling="rustig" form-spelvar="" subcount="0" />

		Number of tables: 0 (1 including the root)

		Usage Example:
			self.saveSimpleAttribStruct(element, sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		'''
		prefix_name = element.tag + "_" 
		for name, value in element.attrib.items():
			if value:
				key = self.covertKey(prefix_name + name, table_name)
				value = self.convertValue(value)
				sql_keys.append(key)
				sql_values.append(value)
				self.print_output(key, value)

	def saveSubAttribStruct(self, element, sql_keys, sql_values, table_name):
		'''
		When there are multiple sub elements either containing a value and/or containing attributes.

		Eg.
		  <pragmatics>
			<prag-socGroup>romcath</prag-socGroup>
			<prag-domain general="true" subjectfield="religie" />
		  </pragmatics>

		Number of tables: 0 (1 including the root)

		Usage Example:
			self.saveSubAttribStruct(element, sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		'''
		for sub_element in element:
			prefix_name = sub_element.tag + "_"
			# Get the atrributes
			if sub_element.attrib:
				for name, value in sub_element.attrib.items():
					if value:
						key = self.covertKey(prefix_name + name, table_name)
						value = self.convertValue(value)
						sql_keys.append(key)
						sql_values.append(value)
						self.print_output(key, value)	
			# Get the value		
			if sub_element.text:
				key = self.covertKey(prefix_name + sub_element.tag, table_name)
				value = self.convertValue(sub_element.text)
				sql_keys.append(key)
				sql_values.append(value)
				self.print_output(key, value)

	def saveMultipleAttribStruct(self, element, super_id_key_name, super_id, overall_sub_output, table_name):
		'''
		When there are multiple sub elements only containg attributes

		Eg #1.
		  <sem-synonyms>
			<sem-synonym r_form="accuraat" />
			<sem-synonym r_form="nauwgezet" />
		  </sem-synonyms>
		Eg #2.
			<synonyms>
				<synonym c_cid_id="10158" c_lu_id="r_n-10061" status="rbn-1-dwn-1"/>
				<synonym c_cid_id="31211" c_lu_id="r_n-25711" status="rbn-1-dwn-1"/>
			</synonyms>

		Number of tables: 1

		Usage Example:
			self.saveMultipleAttribStruct(element, SUBCOUNTS_ID, word_id, overall_sql_semantics_synonyms_output, TABLE_SEMANTICS_SYNONYMS)
		'''
		for sub_element in element:
			if sub_element.attrib:
				prefix_name = sub_element.tag + "_"
				sql_sub_output = []
				sql_sub_output.append('INSERT INTO `' + table_name + '` ({0}) VALUES (')
				sub_sql_keys = []
				sub_sql_values = []
				# super id
				sub_sql_keys.append('`' + super_id_key_name + '`')
				sub_sql_values.append(super_id)
				for name, value in sub_element.attrib.items():
					if value:
						key = self.covertKey(prefix_name + name, table_name)
						value = self.convertValue(value)
						sub_sql_keys.append(key)
						sub_sql_values.append(value)
						self.print_output(key, value)	
				# Combine query
				self.combineSQLQuery(sql_sub_output, sub_sql_keys, sub_sql_values, overall_sub_output)


	def saveMultipleSubAttribStruct(self, element, super_id_key_name, super_id, overall_sub_output, table_name):
		'''
		When there are multiple sub elements only containg attributes 
		and this element has more sub elements only containing attributes

		Happily this sub sub elements can be stored into the sub element table

		Eg.
		<wn_equivalence_relations>
			<relation relation_name="EQ_NEAR_SYNONYM" version="pwn_1_6"...>
				<author name="Irion Technologies" source_id="Wordnet Aligner v2.0" date="20070622" score="76.0" status=""/>
			</relation>
			<relation relation_name="EQ_NEAR_SYNONYM" version="pwn_1_6" ....>
				<author name="Irion Technologies" source_id="Wordnet Aligner v2.0" date="20070622" score="80.0" status=""/>
			</relation>
			<relation relation_name="EQ_NEAR_SYNONYM" version="pwn_1_6" ....>
				<author name="Irion Technologies" source_id="Wordnet Aligner v2.0" date="20070622" score="76.0" status=""/>
			</relation>
		</wn_equivalence_relations>

		Number of tables: 1 (2 including root)

		Usage Example:
			
		'''
		for sub_element in element:
			if sub_element.attrib:
				prefix_name = sub_element.tag + "_"
				sql_sub_output = []
				sql_sub_output.append('INSERT INTO `' + table_name + '` ({0}) VALUES (')
				sub_sql_keys = []
				sub_sql_values = []
				# super id
				sub_sql_keys.append('`' + super_id_key_name + '`')
				sub_sql_values.append(super_id)
				for name, value in sub_element.attrib.items():
					if value:
						key = self.covertKey(prefix_name + name, table_name)
						value = self.convertValue(value)
						sub_sql_keys.append(key)
						sub_sql_values.append(value)
						self.print_output(key, value)
				if len(sub_element) >= 1:
					# Only the first element will be take into account (if there are more)
					sub_sub_element = sub_element[0]
					if sub_sub_element.attrib:
						prefix_name = sub_sub_element.tag + "_"
						for name, value in sub_sub_element.attrib.items():
							if value:
								key = self.covertKey(prefix_name + name, table_name)
								value = self.convertValue(value)
								sub_sql_keys.append(key)
								sub_sql_values.append(value)
								self.print_output(key, value)

				# Combine query
				self.combineSQLQuery(sql_sub_output, sub_sql_keys, sub_sql_values, overall_sub_output)

	###################################
	##     XML Node help fuctions    ##
	###################################

	def saveSimpleStruct(self, element, sql_keys, sql_values, table_name):
		'''
		When the struct has only a list of elements

		Number of tables: 0 (1 including the root)

		Usage example:
			self.saveSimpleStruct(element, sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		'''	
		prefix_name = element.tag + "_" 
		for sub_element in element:
			if sub_element.text:
				key = self.covertKey(prefix_name + sub_element.tag, table_name)
				value = self.convertValue(sub_element.text)
				sql_keys.append(key)
				sql_values.append(value)
				self.print_output(key, value)

	def saveDeeperStruct(self, element, skip_element_tag, sql_keys, sql_values, table_name):
		'''
		When the struct has a deeper node, but can still use the root table.
		So no need to use an extra table

		The skip element tag is the tag where the deeper content is located. This key & value should not be added.

		Number of tables: 0 (1 including the root)

		Usage example:
			self.saveDeeperStruct(element, 'sem-definition', sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		'''	
		prefix_name = element.tag + "_" 
		for sub_element in element:
			if sub_element.text and (sub_element.tag != skip_element_tag):
				key = self.covertKey(prefix_name + sub_element.tag, table_name)
				value = self.convertValue(sub_element.text)
				sql_keys.append(key)
				sql_values.append(value)
				self.print_output(key, value)

			for sub_sub_element in sub_element:
				if sub_sub_element.text:
					key = self.covertKey(prefix_name + sub_sub_element.tag, table_name)
					value = self.convertValue(sub_sub_element.text)
					sql_keys.append(key)
					sql_values.append(value)
					self.print_output(key, value)

	def saveSubTableStruct(self, element, super_id_key_name, super_id,
										sub_element_tag, sub_table_name, overall_sub_output,
										sql_keys, sql_values, table_name):
		'''
		When the struct has one list inside it

		Number of tables: 1 (2 including the root)

		Usage example:
			self.saveSubTableStruct(element, 'ex_id', example_id,
											'sy-complementation', 'cornetto_syntax_complementations', overall_sql_complementations_output,
											sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		'''
		prefix_name = element.tag + "_" 
		for sub_element in element:
			if sub_element.text:
				if sub_element.tag == sub_element_tag:
					# @ATTENTION multi-row!
					for idx, sub_sub_element in enumerate(sub_element):
						if DEBUG:
							print "(" + str(idx) + ")"
						sql_sub_output = []
						sql_sub_output.append('INSERT INTO `' + sub_table_name + '` ({0}) VALUES (')
						sub_sql_keys = []
						sub_sql_values = []
						if sub_sub_element.text:
							# super id
							sub_sql_keys.append('`' + super_id_key_name + '`')
							sub_sql_values.append(super_id)

							key = self.covertKey(sub_sub_element.tag, sub_table_name)
							value = self.convertValue(sub_sub_element.text)
							sub_sql_keys.append(key)
							sub_sql_values.append(value)													
							self.print_output(key, value)		
							# Combine query
							self.combineSQLQuery(sql_sub_output, sub_sql_keys, sub_sql_values, overall_sub_output)
				else:
						key = self.covertKey(prefix_name + sub_element.tag, table_name)
						value = self.convertValue(sub_element.text)
						sql_keys.append(key)
						sql_values.append(value)
						self.print_output(key, value)


	def saveSubSubTableStruct(self, element, super_id_key_name, super_id,
										sub_element_tag, sub_table_name, overall_sub_output,
										sql_keys, sql_values, table_name):
		'''
		When a struct has a struct inside a struct (eg. pair table)

		Number of tables: 1 (2 including the root)

		Usage example:
			self.saveSubSubTableStruct(element, EXAMPLES_ID, example_id,
															'sy-combi', TABLE_COMBIPAIRS, overall_sql_combipair_output,
															sql_examples_keys, sql_examples_values, TABLE_EXAMPLES)
		'''
		prefix_name = element.tag + "_" 
		for sub_element in element:
			if sub_element.text:
				if sub_element.tag == sub_element_tag:
					# @ATTENTION multi-row!
					for idx, sub_sub_element in enumerate(sub_element):
						if DEBUG:
							print "(" + str(idx) + ")"
						if sub_sub_element.text:
							sql_sub_output = []
							sql_sub_output.append('INSERT INTO `' + sub_table_name + '` ({0}) VALUES (')
							sub_sql_keys = []
							sub_sql_values = []

							# super id
							sub_sql_keys.append('`' + super_id_key_name + '`')
							sub_sql_values.append(super_id)
							for sub_sub_sub_element in sub_sub_element:
								if sub_sub_sub_element.text:
									key = self.covertKey(sub_sub_sub_element.tag, sub_table_name)
									value = self.convertValue(sub_sub_sub_element.text)
									sub_sql_keys.append(key)
									sub_sql_values.append(value)													
									self.print_output(key, value)
		
							# Combine query
							self.combineSQLQuery(sql_sub_output, sub_sql_keys, sub_sql_values, overall_sub_output)
				else:
					key = self.covertKey(prefix_name + sub_element.tag, table_name)
					value = self.convertValue(sub_element.text)
					sql_keys.append(key)
					sql_values.append(value)
					self.print_output(key, value)

	def saveDeeperSubSubTableStruct(self, element, super_id_key_name, super_id, 
										sub_element_tag, deeper_sub_element_tag, deeper_sub_table_name, overall_deeper_sub_output,
										sql_keys, sql_values, table_name):
		'''
		When a struct has even a deeper pair table as above fuctions
		
		Number of tables: 1 (2 including the root)		

		Usage example:
			self.saveDeeperSubSubTableStruct(element, 'lu_id', word_id,
												'sem-caseframe', 'args', 'cornetto_semantics_caseframe_args', overall_sql_semantics_caseframe_args_output,
												sql_subcounts_keys, sql_subcounts_values, TABLE_SUBCOUNTS)
		'''
		prefix_name = element.tag + "_" 
		for sub_element in element:
			if sub_element.text:
				if sub_element.tag == sub_element_tag:
					# @ATTENTION multi-row!
					for idx, sub_sub_element in enumerate(sub_element):
						if DEBUG:
							print "(" + str(idx) + ")"
						if sub_sub_element.text:
							if sub_sub_element.tag == deeper_sub_element_tag:
								for idx, deeper_sub_sub_element in enumerate(sub_sub_element):
									if DEBUG:
										print "(" + str(idx) + ")"									
									if deeper_sub_sub_element.text:
										sql_sub_output = []
										sql_sub_output.append('INSERT INTO `' + deeper_sub_table_name + '` ({0}) VALUES (')
										sub_sql_keys = []
										sub_sql_values = []

										# super id
										sub_sql_keys.append('`' + super_id_key_name + '`')
										sub_sql_values.append(super_id)
										for sub_sub_sub_element in deeper_sub_sub_element:
											if sub_sub_sub_element.text:
												key = self.covertKey(sub_sub_sub_element.tag, deeper_sub_table_name)
												value = self.convertValue(sub_sub_sub_element.text)
												sub_sql_keys.append(key)
												sub_sql_values.append(value)													
												self.print_output(key, value)
		
										# Combine query
										self.combineSQLQuery(sql_sub_output, sub_sql_keys, sub_sql_values, overall_deeper_sub_output)
				else:
					key = self.covertKey(prefix_name + sub_element.tag, table_name)
					value = self.convertValue(sub_element.text)
					sql_keys.append(key)
					sql_values.append(value)
					self.print_output(key, value)

	def print_output(self, key, value, forced=False):
		if forced:
			print key + " = " + value + "     (forced output)"

		if DEBUG:
			print key + " = " + value


	def writeToFile(self, subcounts_queries, examples_queries, combipair_queries,
					complementation_queries, semantics_caseframe_args_queries, 
					morphology_flex_conjugation_quries, morphology_plurforms_queries, 
					semantics_synonyms_queries, selrestrictions_queries,

					synset_queries, synonyms_queries, wordnet_domains_queries,
					wordnet_internal_relations_queries, wordnet_equivalence_relations_queries,
					sumo_relations_queries):
		"""
		Write all queries to file
		"""
		f = open(OUTPUT_FILE,'w')
		f.write("USE `" + DATABASE_NAME + "`;\n\n")

		# Lexical unit tables
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_SUBCOUNTS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in subcounts_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_EXAMPLES + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in examples_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_COMBIPAIRS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in combipair_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_STYNTAX_COMPLEMENTATIONS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in complementation_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_SEMATICS_CASEFRAME_ARGS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in semantics_caseframe_args_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_MORPHOLOGY_FLEX_CONJUGATION + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in morphology_flex_conjugation_quries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_MORPHOLOGY_PLURFORMS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in morphology_plurforms_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_SEMANTICS_SYNONYMS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in semantics_synonyms_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_SELRESTRICTIONS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in selrestrictions_queries:
			f.write(query + "\n")

		# Synset tables
		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_SYNSETS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in synset_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_SYNONYMS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in synonyms_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_WORDNET_DOMAINS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in wordnet_domains_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_WORDNET_INTERNAL_RELATIONS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in wordnet_internal_relations_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_WORDNET_EQUIVALENCE_RELATIONS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in wordnet_equivalence_relations_queries:
			f.write(query + "\n")

		f.write("\n\n")
		f.write("-- -----------------------------------------------------\n")
		f.write("-- Data for table `" + DATABASE_NAME +"`.`" + TABLE_SUMO_RELATIONS + "`\n")
		f.write("-- -----------------------------------------------------\n")
		for query in sumo_relations_queries:
			f.write(query + "\n")

		f.close()

if __name__ == '__main__':
	converter = ConvertToSQL()
	converter.convert()

